---
layout: post
title: Ideas and takeaways from DDD Europe 2018
tags: [domain driven design,architecture,testing,conference,wikimedia]
description: Ideas and takeaways from the talks and workshops I attended at DDD Europe
---

## Keynote by David Snowden
An inspiring talk about complexity and modeling, using the [Cynefin  framework](https://en.wikipedia.org/wiki/Cynefin_framework) to understand the nature of your domain (Complex/Complicated/Simple/Chaotic) and how to model and measure success according to that nature. What stood out to me was the idea that complex domains - like ecosystems, financial markets, large organizations or even "society" itself - can't be analyzed and fully understood like complicated domains. Thus, they can't be "modeled", since every abstraction will miss crucial behavior. Changes to the system will always have unforeseen side effects and insight in the behavior and side effects of changes can only be gained by running small, parallel "experiments" and checking their outcome. Parallel experiments are needed to avoid falling into the trap of the [Hawthorne effect](https://en.wikipedia.org/wiki/Hawthorne_effect), where improvements in a system come from the *introduction* of change and *observing the outcome* than from the change itself.

## Domain Language Throughout Tests, combining DDD and BDD
In a series of evolving code examples [Kenny Baas](https://mobile.twitter.com/kenny_baas) showed that your behavior-driven tests - especially the browser tests - become much more understandable, if the  Selenium commands that normally drive browser tests, are encapsulated in method/class names that express the domain language.

Also, I liked his heuristic of when to use the [Gherkin](https://github.com/cucumber/cucumber/wiki/Gherkin) style of writing BDD tests: If you need to communicate the behavior of your system back and forth with the domain experts, use Gherkin because it's mostly "natural language". If you don't need to communicate as much, use a BDD testing tool where you specify the behavior in code.

## From Legacy Chaos to the Promised Land of DDD
A case study how a team of developers at Statoil improved their server-side legacy code to become more structured and domain driven. Interesting ideas for me were:

Different people have different learning styles when it comes to coding practices: Some like detailed instructions beforehand, some like 1:1 sessions with experienced developers, some like fending on their own without "interruptions" and having a code review afterwards. Try to get a feeling or ask people how they would like to learn.

Feature toggles are a very helpful tool and can also be used for switching from legacy parts of the code to refactored bounded contexts while still allowing for switching back to the working old code in case of an unforeseen emergency.

## From Front to Back: Homomorphic event sourcing
I was in a food coma while listening to this talk, so I fear I can't do it justice, but I'll try to give my summary.

When frontend and backend are developed independently there has to be a contract on how they communicate, how the domain commands and domain events on the frontend and backend are mapped. Usually, formulating the possible inputs for the backend and the possible outputs for the frontend is manual labor, but when using the domain language, some of that test-case writing can be automated.

If you look at the domain commands and domain events of the backend, they can be seen as a kind of state machine or formal language. This state machine description can be used to generate unit tests for the backend contract and test stubs for the frontend contract, using the [quickcheck library](http://hypothesis.works/articles/quickcheck-in-every-language/).  

## Find Context Boundaries with Domain Storytelling
In Domain Storytelling, you listen to the domain experts explaining the typical scenarios of their domain, while documenting the actors, events/commands and domain objects you discover in an easy to understand iconography. The resulting diagram is a mix of icons, arrows and text. Actions read almost sentence-like. Also, there is no branching involved, if scenarios need different handling, then it's better to draw different scenarios "3 examples are better than 1 abstraction".

The talk introduced a way to find context boundaries with the help of the domain storytelling. Indicators that there might be a context boundary are:

- One way information flow
- Difference in language (e.g. the same thing has two names)
- Different triggers (e.g. "on demand" vs "at regular intervals")

In the workshop on day 2 we tried to model the domain of reserving and buying movie tickets in various scenarios: At the counter, on a web site, through an online app. The main lesson I took from the workshop was to avoid language and processes that are too "technical" (button, click, request, response) and think more in domain terms: reserve ticket, show seat plan, lock seat temporarily, etc. The other lesson I learned was that domains and processes that look simple on the outside, might still contain lots of complexity, as soon as you try to describe them.

## Keynote by Eric Evans
In this talk the author of "Domain-Driven Design: Tackling Complexity in Software" itself talked about exploring a "supporting subdomain". This was a good example on how to sharpen your "domain thinking" skills and overcoming "Legacy Blindness", a state where you no longer see the quirks of your chosen model for a domain. The chosen supporting domain was "Times and Dates", which already has at least one solution that is widely used, in this case the Java Data and Time API. He showed his differing approaches, most of them functional, written in Clojure. The two exploration recipes were "Find awkward examples and hard-to-express edge cases in the current model" and "Produce variation".

The seemingly simple example inspired me and my colleagues to talk about seemingly "simple" domains like "Money" and "Currency" during our after-conference beer and we discovered the intricacies there as well.

## Modeling for failure
This talk was about building software systems that mirror and document real-life processes, with the treatment steps in and emergency room and the enrollment in a drug detox program as an examples. You have to think about the big "state diagram" of the process and allow for transitions and their reversal that are not obvious from the first description of the process.

## Readable code
readable === understandable
terseness is sometimes good, use intermediate variables.


## Overall impression & general notes
The organizers put real effort into making the conference more accessible:

One good accessibility feature for introverts like me: the quiet room. A big conference like this can get very noisy with all the people (up to 95 db according to my app).
